---
title: 'Contributing an Integration'
description: 'Developing a fully working OpenOps block to integrate with a third party service'
icon: 'code'
---

[Contributing a minimal block](/contributing/contributing-a-minimal-block/) demonstrated how to use scaffolding and make a block show up in the OpenOps UI. Let's now see how you would create a fully functional integration with a third-party service.

OpenOps integrates with Jira Cloud and Linear, but what if you use a different service for tracking your cloud optimization opportunities? Let's see how you would create a block that integrates with [JetBrains YouTrack](https://www.jetbrains.com/youtrack/). This involves implementing API key based authentication and designing a couple actions that interact with the [YouTrack API](https://www.jetbrains.com/help/youtrack/devportal/youtrack-rest-api.html).

This is not a step-by-step guide. Instead, it's an overview that highlights prominent parts of the process.

## Scaffolding a new block

To scaffold a new block, you run the following command:

```bash
npm run cli blocks create
```

For a YouTrack integration, you would supply the following information to the CLI:

1. `Block name`: "youtrack" (lowercase).
2. `Package name`: leave blank to use the default name.
3. `Authentication type`: select `Custom (Custom properties)`.
4. `Create opinionated folder structure with stubs for actions, tests, and common service layer`: select `Yes - Create full folder structure with stubs`.

OpenOps generates a full project template inside `packages/blocks/youtrack/`, including `package.json`, TypeScript configuration files, ESLint and Jest configuration files, an entry point for the block at `src/index.ts` and a starter test file at `test/index.test.ts`.

Let's take a closer look at the generated files.

### src/index.ts

`src/index.ts`  is the entry point to the new block. It uses the `createBlock()` function from the OpenOps block framework to create a new block. This function takes a number of arguments, of which the most important ones are:
* `auth`: authentication implementation for the block. It defines which credentials the user needs to specify in your block's [connection](/cloud-access/access-levels-permissions) properties to authenticate with the API that the block integrates with.
* `actions`: an array that contains the actions that the block exposes. The scaffolded version includes a predefined action that allows making a custom API call to the block's API.

```ts
import { createCustomApiCallAction } from '@openops/blocks-common';
import { createBlock, Property } from '@openops/blocks-framework';
import { BlockCategory } from '@openops/shared';
import { youtrackAuth } from './lib/auth';

export const youtrack = createBlock({
  displayName: 'Youtrack',
  auth: youtrackAuth,
  minimumSupportedRelease: '0.20.0',
  logoUrl: 'https://static.openops.com/blocks/youtrack.png',
  authors: [],
  categories: [BlockCategory.FINOPS],
  actions: [
    createCustomApiCallAction({
      baseUrl: () => 'https://api.youtrack.com',
      auth: youtrackAuth,
      additionalProps: {
        documentation: Property.MarkDown({
          value:
            'For more information, visit the [Youtrack API documentation](https://docs.youtrack.com/reference/introduction).',
        }),
      },
    }),
  ],
  triggers: [],
});
```

### src/lib/auth.ts

Scaffolding generates a placeholder authentication implementation in a separate file. It uses a `CustomAuth()` helper function from the OpenOps block framework. The function takes several parameters, of which the most important ones are:
* `props`: an object that defines the inputs necessary to authenticate with the service provider that the block integrates with.
* `validate`: a function for optional validation of the inputs provided in `props`.

```ts
import { BlockAuth, Property } from '@openops/blocks-framework';

export const youtrackAuth = BlockAuth.CustomAuth({
  authProviderKey: 'youtrack',
  authProviderDisplayName: 'Youtrack',
  authProviderLogoUrl: 'https://static.openops.com/blocks/youtrack.png',
  description: 'Configure your Youtrack connection',
  required: true,
  props: {
    apiKey: Property.SecretText({
      displayName: 'API Key',
      required: true,
    }),
    baseUrl: Property.ShortText({
      displayName: 'Base URL',
      description: 'The base URL for Youtrack API',
      required: true,
    }),
  },
  validate: async ({ auth }) => {
    // Add validation logic here
    return { valid: true };
  },
});
```

### Project files

OpenOps uses [Nx](https://nx.dev/) as its build system, and `project.json` is the Nx project file that defines how the new block is built, tested, and linted in an Nx workspace. It sets the source root, output path, TypeScript config, package entry points, and assets, and declares executors for build (`@nx/js:tsc`), test (`@nx/jest:jest`), and lint (`@nx/eslint:lint`).

```json
{
  "name": "blocks-youtrack",
  "$schema": "../../../node_modules/nx/schemas/project-schema.json",
  "sourceRoot": "packages/blocks/youtrack/src",
  "projectType": "library",
  "tags": [],
  "targets": {
    "build": {
      "executor": "@nx/js:tsc",
      "outputs": ["{options.outputPath}"],
      "options": {
        "outputPath": "dist/packages/blocks/youtrack",
        "tsConfig": "packages/blocks/youtrack/tsconfig.lib.json",
        "packageJson": "packages/blocks/youtrack/package.json",
        "main": "packages/blocks/youtrack/src/index.ts",
        "assets": ["packages/blocks/youtrack/*.md"],
        "buildableProjectDepsInPackageJsonType": "dependencies",
        "updateBuildableProjectDepsInPackageJson": true
      }
    },
    "test": {
      "executor": "@nx/jest:jest",
      "outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
      "options": {
        "jestConfig": "packages/blocks/youtrack/jest.config.ts"
      }
    },
    "lint": {
      "executor": "@nx/eslint:lint",
      "outputs": ["{options.outputFile}"]
    }
  }
}
```

`package.json` is a minimal metadata file declaring the block's name and version within the Nx workspace. Unlike typical npm packages and as opposed to the Activepieces extension practices, this file isn't meant for publication to the npm registry. Instead, it mainly helps Nx identify the project and marks the block as a versioned unit inside the larger repository.

```json
{
  "name": "@openops/block-youtrack",
  "version": "0.0.1"
}
```

If you need extra dependencies for your block, such as an SDK for your service, you can later add them to the `dependencies` section of `package.json`.

### Test files

`test/index.test.ts` is a stub Jest test fixture that includes a few sample tests for the block. Tests in this fixture can be executed by running `nx test blocks-youtrack`.

```ts
import { youtrack } from '../src/index';

describe('block declaration tests', () => {
  test('should return block with correct authentication', () => {
    expect(youtrack.auth).toMatchObject({
      type: 'CUSTOM_AUTH',
      required: true,
      authProviderKey: 'youtrack',
      authProviderDisplayName: 'Youtrack',
      authProviderLogoUrl: 'https://static.openops.com/blocks/youtrack.png',
    });
  });

  test('should return block with correct number of actions', () => {
    expect(Object.keys(youtrack.actions()).length).toBe(1);
    expect(youtrack.actions()).toMatchObject({
      custom_api_call: {
        name: 'custom_api_call',
        requireAuth: true,
      },
    });
  });
});
```

There's also a Jest configuration file, `jest.config.ts`, that inherits shared settings from OpenOps' Jest preset, references a TypeScript config file, defines recognized file extensions and specifies where to store code coverage reports:

```ts
export default {
  displayName: 'blocks-youtrack',
  preset: '../../../jest.preset.js',
  setupFiles: ['../../../jest.env.js'],
  testEnvironment: 'node',
  transform: {
    '^.+\\.[tj]s$': ['ts-jest', { tsconfig: '<rootDir>/tsconfig.spec.json' }],
  },
  moduleFileExtensions: ['ts', 'js', 'html'],
  coverageDirectory: '../../../coverage/packages/blocks/youtrack',
};
```

### TypeScript configuration files

Scaffolding generates three TypeScript configuration files: `tsconfig.json`, `tsconfig.lib.json`, and `tsconfig.spec.json`

`tsconfig.json` is the base config for the block. It extends the workspace's root `tsconfig.base.json` and enforces strict compiler options but doesn't include any source files directly. Instead, it references the other two config files, serving as an entry point for both:

```json
{
  "extends": "../../../tsconfig.base.json",
  "compilerOptions": {
    "module": "commonjs",
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true
  },
  "files": [],
  "include": [],
  "references": [
    {
      "path": "./tsconfig.lib.json"
    },
    {
      "path": "./tsconfig.spec.json"
    }
  ]
}
```

`tsconfig.lib.json` applies to the block's source code. It outputs compiled files to `dist/out-tsc`, generates type declarations, and includes only non-test TypeScript files under `src/`:

```json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "../../../dist/out-tsc",
    "declaration": true,
    "types": ["node"]
  },
  "exclude": ["jest.config.ts", "src/**/*.spec.ts", "src/**/*.test.ts"],
  "include": ["src/**/*.ts"]
}
```

`tsconfig.spec.json` is tailored for testing. It includes test and declaration files and sets up Jest typings:

```json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "../../../dist/out-tsc",
    "module": "commonjs",
    "types": ["jest", "node"]
  },
  "include": [
    "jest.config.ts",
    "src/**/*.test.ts",
    "src/**/*.spec.ts",
    "src/**/*.d.ts"
  ]
}
```

### Other files

`.eslintrc.json` defines JavaScript and TypeScript linting behavior for the block, extending the OpenOps repository's root ESLint configuration. The `overrides` section provides placeholders for block-specific linting rules in case you feel like introducing them.

`README.md` stubs out documentation for the block.

## Post-scaffolding cleanup

OpenOps may alter the spelling of your block's display name when running scaffolding, so you may want to review this and run search and replace if needed. With YouTrack, it didn't use the proper casing for the product name, using "Youtrack" instead of "YouTrack".

Note that OpenOps also generates a stub logo URL at the static.openops.com domain, which doesn't exist. To see your product's logo in the OpenOps UI during development, consider replacing the stub logo URL with a URL on a server that you control. For example, for YouTrack, the https://static.openops.com/blocks/youtrack.png stub URL can be replaced with a [live YouTrack logo URL](https://resources.jetbrains.com/storage/products/company/brand/logos/YouTrack_icon.png). Alternatively, you can keep the stub as is and ask OpenOps to upload your logo when you open a PR.

Even this basic scaffolding introduces the new block to the OpenOps UI, even though the block doesn't do much yet. Here's what you can see at this point if you run `npm run start` and open the OpenOps frontend at http://localhost:4200/ in your browser:

![The scaffolded block in OpenOps UI](/images/contributing/youtrack-in-the-ui.png)

## Implementing authentication (and getting a connection for free)

Now that you have a block, you could get right to building its actions. However, unless your block interacts with a publicly accessible API, you need to provide the user with a way to authenticate with the API that your block is built upon. How you implement authentication defines what the user will see when they try to create a new [connection](/cloud-access/access-levels-permissions) for your block.

Scaffolding generated a placeholder authentication implementation and referenced it from the YouTrack block's entry point. What's left to do is implement the actual authentication logic in the `src/lib/auth.ts` file. As a reminder, here's what the scaffolded file initially looked like:

```ts
import { BlockAuth, Property } from '@openops/blocks-framework';

export const youtrackAuth = BlockAuth.CustomAuth({
  authProviderKey: 'youtrack',
  authProviderDisplayName: 'Youtrack',
  authProviderLogoUrl: 'https://static.openops.com/blocks/youtrack.png',
  description: 'Configure your Youtrack connection',
  required: true,
  props: {
    apiKey: Property.SecretText({
      displayName: 'API Key',
      required: true,
    }),
    baseUrl: Property.ShortText({
      displayName: 'Base URL',
      description: 'The base URL for Youtrack API',
      required: true,
    }),
  },
  validate: async ({ auth }) => {
    // Add validation logic here
    return { valid: true };
  },
});
```

As you can see, this block uses a `CustomAuth()` helper function to define YouTrack authentication. There are other [types of authentication](/contributing/authentication/), but `CustomAuth()` works best for YouTrack because apart from an API key, the user needs to specify a base URL as YouTrack can be cloud-hosted by JetBrains, with a base URL different for each cloud instance, or self-hosted by customers.

The values of `authProviderKey`, `authProviderDisplayName`, `authProviderLogoUrl` and `required` properties are just fine as they are. What needs to be changed are the values of `props`, `validate`, and `description`. Let's start with `props`.

### Defining connection properties

`props` defines the inputs necessary to authenticate with the service provider that the block integrates with. Each of these inputs is an OpenOps UI component that can be a regular or a masked input field, a checkbox, a dropdown, and more. To learn more about the component library, see [Activepieces documentation](https://www.activepieces.com/docs/developers/piece-reference/properties). This component library is not only used in defining connections, but also in actions that a block exposes.

The first property, `apiKey`, is for the user to provide a YouTrack API key a.k.a. a permanent token. The scaffolded version of this property uses a `SecretText` property type, which is a masked input field, and it's just what we need to this kind of data. Let's expand the scaffolded version of the property to include a description:

```ts
apiKey: Property.SecretText({
  required: true,
  displayName: 'API key',
  description:
    'The API key (permanent token) for your YouTrack installation.',
})
````

The second property, `apiUrl`, is for the user to provide a base URL for their YouTrack instance. This property is a regular input field. The scaffolded version is a good start, but we can improve it by adding a better description, providing a default value, and using a predefined validation rule for URLs:

```ts
apiUrl: Property.ShortText({
  displayName: 'Base URL',
  description:
    'The base URL of your YouTrack installation without a trailing slash.',
  required: true,
  validators: [Validators.url],
  defaultValue: 'https://your-instance.myjetbrains.com/youtrack',
})
```

Note that for this to compile, we need to extend the import from the `@openops/blocks-framework` package to include the `Validators` object:

```ts
import { BlockAuth, Property, Validators } from '@openops/blocks-framework';
```

`Validators.url` is not the only predefined validation rule. OpenOps provides an array of ready-to-use validation rules for value ranges, dates, emails, phone numbers, image formats, and more.

### Adding custom validation

Adding predefined validation rules to properties is one way of enforcing a certain format or pattern for user input. You can also add custom validation rules using the `validate()` function.

Some blocks, such as [Linear](https://github.com/openops-cloud/openops/blob/7fad45c16a0ab4a01eaa5a2b9b50d304effc9f83/packages/blocks/linear/src/index.ts#L29C1-L39C5), use `validate()` to make sure that the API key confirms to a specific format. With YouTrack, there's no need to do this. Instead, it's reasonable to check that the base URL doesn't have a trailing slash as YouTrack doesn't normalize URLs with double slashes. Here's how this could be done:

```ts
validate: async ({ auth }) => {
  if (auth.apiUrl.endsWith('/')) {
    return {
      valid: false,
      error: 'Base URL must not end with a slash',
    };
  } else {
    return { valid: true };
  }
}
```

The `auth` object passed to `validate()` contains the values of all the properties that the user has provided. This lets you introduce any additional checks on `auth.apiUrl`, which holds the entered base URL value.

You could also use `validate()` to try to authenticate the user with a given API key. For example, the
[ServiceNow](https://github.com/openops-cloud/openops/blob/7fad45c16a0ab4a01eaa5a2b9b50d304effc9f83/packages/blocks/servicenow/src/lib/auth.ts#L34C1-L54C5) and [Umbrella](https://github.com/openops-cloud/openops/blob/7fad45c16a0ab4a01eaa5a2b9b50d304effc9f83/packages/blocks/anodot/src/lib/anodot-auth-property.ts#L37C1-L64C5) blocks make sample requests to their APIs to tell the user right away if authentication fails.

### Adding a Markdown description

When a user sets up a connection, they don't necessarily know right away how to obtain an API key or a different value that they're expected to enter during connection setup.

To guide them, use the `description` property. The best part about this property is that it's not limited to plain text; instead, you can provide a Markdown-formatted string, and OpenOps will render it in the connection UI, between the title and the first input.

For YouTrack, a Markdown description could look like this:

```ts
const markdown = `
To get your YouTrack API key:
1. Go to your YouTrack installation.
2. In the navigation menu, click your user profile icon, then click **Profile**.
3. Open the **Account Security** tab.
4. Under **Tokens**, click **New token**.
5. Give the new token a name and select **YouTrack** in the list of scopes.
6. Click **Create**.
7. Copy the token to your clipboard.`;
```

When providing a description as a separate variable as shown here, remember to assign the variable to the `description` property:

```ts
description: markdown
```

### Adding an interface

The last thing to do in the `src/lib/auth.ts` file is to define an interface for the two authentication properties. This interface will be imported in files defining the block's actions to provide typing to the parameters of the actions.

For YouTrack authentication, the interface could look like this:

```ts
export interface YouTrackAuth {
  apiUrl: string;
  apiKey: string;
}
```

### The resulting authentication code and connection UI

After implementing authentication, the `src/lib/auth.ts` file looks like this:

```ts
import { BlockAuth, Property, Validators } from '@openops/blocks-framework';

const markdown = `
To get your YouTrack API key:
1. Go to your YouTrack installation.
2. In the navigation menu, click your user profile icon, then click **Profile**.
3. Open the **Account Security** tab.
4. Under **Tokens**, click **New token**.
5. Give the new token a name and select **YouTrack** in the list of scopes.
6. Click **Create**.
7. Copy the token to your clipboard.`;

export const youtrackAuth = BlockAuth.CustomAuth({
  required: true,
  authProviderKey: 'youtrack',
  authProviderDisplayName: 'YouTrack',
  authProviderLogoUrl:
    'https://resources.jetbrains.com/storage/products/company/brand/logos/YouTrack_icon.png',
  description: markdown,
  props: {
    apiKey: Property.SecretText({
      required: true,
      displayName: 'API key',
      description:
        'The API key (permanent token) for your YouTrack installation.',
    }),
    apiUrl: Property.ShortText({
      displayName: 'Base URL',
      description:
        'The base URL of your YouTrack installation without a trailing slash.',
      required: true,
      validators: [Validators.url],
      defaultValue: 'https://your-instance.myjetbrains.com/youtrack',
    }),
  },
  validate: async ({ auth }) => {
    if (auth.apiUrl.endsWith('/')) {
      return {
        valid: false,
        error: 'Base URL must not end with a slash',
      };
    } else {
      return { valid: true };
    }
  },
});

export interface YouTrackAuth {
  apiUrl: string;
  apiKey: string;
}
```

With this code, if the user chooses to create a new connection in OpenOps, they will see a connection type for YouTrack:

![A YouTrack connection type in OpenOps UI](/images/contributing/youtrack-connection-type.png)

When they click the YouTrack logo, they will see a connection dialog with a properly rendered Markdown description and three input fields. The **Connection name** field is predefined and prefilled with a suggested name of the connection. The other two fields, **API key** and **Base URL**, are the two properties that we defined earlier:

![A YouTrack connection dialog](/images/contributing/youtrack-connection-dialog.png)

If the user enters a base URL with a trailing slash, the connection dialog will execute the validation logic we've defined above and show an error message:

![Base URL validation error](/images/contributing/youtrack-connection-validation.png)

## Adding a simple action

We have a block, we've implemented authenticaton, and now it's time to proceed to developing the meat of every integration: actions.

### Removing the default action

When you scaffold a block, OpenOps adds an action called "Custom API Call". While we could tweak it to make it work for YouTrack, let's instead remove it and create a new action from scratch.

After removing the scaffolded action, the `src/index.ts` file looks like this:

```ts
import { createBlock } from '@openops/blocks-framework';
import { BlockCategory } from '@openops/shared';
import { youtrackAuth } from './lib/auth';

export const youtrack = createBlock({
  displayName: 'YouTrack',
  auth: youtrackAuth,
  minimumSupportedRelease: '0.20.0',
  logoUrl:
    'https://resources.jetbrains.com/storage/products/company/brand/logos/YouTrack_icon.png',
  authors: [],
  categories: [BlockCategory.FINOPS],
  actions: [],
  triggers: [],
});
```

The `actions` array is now empty. As soon as we have an action, we'll need to add a reference to it there.

### Scaffolding the new action

OpenOps provides scaffolding for actions, too, so let's run this in the terminal:

```bash
npm run cli actions create
```

The CLI asks three questions to help define the new action:

1. `Enter the block folder name`: this should be the folder where the block for the new action resides. For the existing YouTrack block, the value shoud be `youtrack`
2. `Enter the action display name`: this should be a human-readable name for the action that users will see in the UI, and it's  also used to name a file for the action. We want to create an action that simply lists issues in a YouTrack instance, so let's call it `Get all issues`.
3. `Enter the action description`: this should be a brief, informative text to show in the UI to explain the function and purpose of the action. Let's use the following: `Retrieves all issues from a YouTrack instance`.

With these values, the CLI scaffolds the action in a new file called `get-all-issues.ts` in the YouTrack block's `/src/lib/actions` directory. The file initially looks like this:

```ts
import { createAction, Property } from '@openops/blocks-framework';

export const getAllIssues = createAction({
  requireToolApproval: false,
  name: 'getAllIssues',
  displayName: 'Get all issues',
  description: 'Retrieves all issues from a YouTrack instance',
  props: {},
  async run() {
    // Action logic here
  },
});
```

As you can see, the scaffolding uses the `createAction()` helper function to define the action. The values of `displayName` and `description` are the same as we provided in the CLI.

The `props` property is empty, which means there are no configuration options for the user to set. For this first action, this is fine: we'll add another action with configuration options later.

### Adding the action logic

The scaffolded action has two prominent omissions:
1. It doesn't have an `auth` property that references the block's authentication logic that we've implemented earlier.
2. Its `run()` function that should define the action logic is empty.

Let's fix these two issues by replacing the scaffolded version with the following:

```ts
import { httpClient, HttpMethod } from '@openops/blocks-common';
import { createAction } from '@openops/blocks-framework';
import { youtrackAuth, YouTrackAuth } from '../auth';

export const getAllIssues = createAction({
  requireToolApproval: false,
  name: 'getAllIssues',
  displayName: 'Get all issues',
  description: 'Retrieves all issues from a YouTrack instance',
  props: {},
  auth: youtrackAuth,
  async run(context) {
    const endpoint =
      '/api/issues?query=for:%20me%20%23Unresolved%20&fields=id,project(shortName),numberInProject,summary,description&$top=10';
    const auth = context.auth as YouTrackAuth;
    const requestUrl = `${auth.apiUrl}${endpoint}`;

    const response = await httpClient.sendRequest({
      method: HttpMethod.GET,
      url: requestUrl,
      headers: {
        Authorization: `Bearer ${auth.apiKey}`,
        Accept: 'application/json',
        'Content-Type': 'application/json',
      },
    });

    return {
      _debug: {
        request: {
          method: 'GET',
          requestUrl,
        },
        response: {
          status: response.status,
        },
      },
      issues: response.body,
    };
  },
});
```

Here's what's changed:
1. The action now has an `auth` property that references the block's authentication logic. Both the authentication logic and the interface for it are imported from the block's `auth.ts` file.
2. The `run()` function now makes a request to a YouTrack API endpoint to retrieve the first 10 unresolved issues.
3. In making the API call, the `run()` function makes use of the imported `httpClient` constant, which is an OpenOps-provided wrapper over the Axios HTTP client. Some blocks, such as [Linear](http://github.com/openops-cloud/openops/blob/main/packages/blocks/linear/src/lib/common/client.ts) and [Jira](https://github.com/openops-cloud/openops/blob/main/packages/blocks/jira-cloud/src/lib/common/index.ts), create separate functions to make HTTP requests to their APIs. This can be helpful for providing extra error handling or making use of existing SDKs, but for YouTrack, we can just use the `httpClient` directly.
4. The `return` statement of the `run()` function is what the user will see as the output of running the action. The format of the returned object is up to the block author. In this case, we're returning an object with two properties: `_debug` and `issues`. The `_debug` property is a container for debugging information that can be useful for troubleshooting during development. The `issues` property is an array of issues that the action retrieved from the YouTrack instance.

### Referencing the action from the block definition

Before we can test the action, we need to add it to the block's definition. Back in the `src/index.ts` file, we need to import this action and add it to the `actions` array:

```ts
import { createBlock } from '@openops/blocks-framework';
import { BlockCategory } from '@openops/shared';
import { getAllIssues } from './lib/actions/get-all-issues';
import { youtrackAuth } from './lib/auth';

export const youtrack = createBlock({
  displayName: 'YouTrack',
  auth: youtrackAuth,
  minimumSupportedRelease: '0.20.0',
  logoUrl:
    'https://resources.jetbrains.com/storage/products/company/brand/logos/YouTrack_icon.png',
  authors: [],
  categories: [BlockCategory.FINOPS],
  actions: [getAllIssues],
  triggers: [],
});
```

### Testing the action

Let's see what happens in the OpenOps UI now that we have the action in place.

First, the action is now visible in the workflow editor and available for selection:

![The Get All Issues action in the workflow editor](/images/contributing/youtrack-get-all-issues-action-selector.png)

In the **Configure** tab of the action's properties pane, there's a connection selector, which comes for free because the action requires authentication. There are also two toggles, **Continue on Failure** and **Retry on Failure**, which are available for all actions. There are no properties specific to this action as we have not defined any.

![The properties pane for Get All Issues](/images/contributing/youtrack-get-all-issues-properties-pane.png)

If we go to the **Test** tab and click **Test Step**, the action will connect to the YouTrack instance configured in the connection and return results in the format defined by the return statement in the action's `run()` function:

![The output of the Get All Issues action](/images/contributing/youtrack-get-all-issues-output.png)

## Adding an action with properties

We've seen how to create a simple action that doesn't require any configuration. More often than not, real-world actions do require the user to enter or select values in the properties pane, and the values of these properties often depend on one another.

For a YouTrack integration, it would make sense to enable the user not only to get the list of issues, but also to update specific issues. Let's add a new action that allows the user to change the status of an issue. This action will include several configurable properties, and one of these properties will depend on the value of another property.

### Scaffolding the new action

First, let's use the OpenOps scaffolding to create a stub for the new action:

```bash
npm run cli actions create
```

The values to feed to the CLI will be as follows:

1. `Enter the block folder name`: same as before, this should be `youtrack`.
2. `Enter the action display name`: let's call the new action `Change issue status`.
3. `Enter the action description`: let's describe the action as `Updates the status of a given issue`.

With these values, the CLI scaffolds the action in a new file called `change-issue-status.ts` in the YouTrack block's `/src/lib/actions` directory:

```ts
import { createAction, Property } from '@openops/blocks-framework';

export const changeIssueStatus = createAction({
  requireToolApproval: false,
  name: 'changeIssueStatus',
  displayName: 'Change issue status',
  description: 'Updates the status of a given issue',
  props: {},
  async run() {
    // Action logic here
  },
});
```

### Referencing the action from the block definition

This time, let's reference the new action in the block's definition (`src/index.ts`) before working on the action logic:

```ts
import { createBlock } from '@openops/blocks-framework';
import { BlockCategory } from '@openops/shared';
import { changeIssueStatus } from './lib/actions/change-issue-status';
import { getAllIssues } from './lib/actions/get-all-issues';
import { youtrackAuth } from './lib/auth';

export const youtrack = createBlock({
  displayName: 'YouTrack',
  auth: youtrackAuth,
  minimumSupportedRelease: '0.20.0',
  logoUrl:
    'https://resources.jetbrains.com/storage/products/company/brand/logos/YouTrack_icon.png',
  authors: [],
  categories: [BlockCategory.FINOPS],
  actions: [getAllIssues, changeIssueStatus],
  triggers: [],
});
```

### Adding authentication and imports

Back in the action file, let's start by referencing the authentication logic we've defined earlier. While we're at it, let's also import the `YouTrackAuth` interface, as well as the HTTP client that OpenOps provides:

```ts
import { httpClient, HttpMethod } from '@openops/blocks-common';
import { createAction, Property } from '@openops/blocks-framework';
import { YouTrackAuth, youtrackAuth } from '../auth';

export const changeIssueStatus = createAction({
  auth: youtrackAuth,
  requireToolApproval: false,
  name: 'changeIssueStatus',
  displayName: 'Change issue status',
  description: 'Updates the status of a given issue',
  props: {},
  async run() {
    // Action logic here
  },
});
```

### Adding an interface representing a YouTrack project

Before adding properties, let's define an interface for the YouTrack project that the issue being updated belongs to. We'll use it both in the property that helps select a project and in another property that depends on it.

We could create the interface in a separate file, but placing it at the end of the `change-issue-status.ts` file should work, too:

```ts
interface YouTrackProject {
  id: string;
  name: string;
  shortName: string;
}
```

### Adding a dropdown property to select a project

We can now add the first property to the `props` parameter of `createAction()`. It will represent a dropdown allowing the user to select a YouTrack project that the issue being updated belongs to:

```ts
props: {
  project: Property.Dropdown({
    displayName: 'Project',
    required: true,
    refreshers: ['auth'],
    options: async ({ auth }) => {
      if (!auth) {
        return {
          options: [],
        };
      }

      const requestAuth = auth as YouTrackAuth;

      const projectsRequest = await httpClient.sendRequest({
        method: HttpMethod.GET,
        url: `${requestAuth.apiUrl}/api/admin/projects?fields=id,name,shortName`,
        headers: {
          Authorization: `Bearer ${requestAuth.apiKey}`,
          Accept: 'application/json',
          'Content-Type': 'application/json',
        },
      });

      return {
        options: projectsRequest.body.map((project: YouTrackProject) => {
          return {
            label: project.name,
            value: project,
          };
        }),
      };
    },
  }),
}
```

Here's what happens inside the `project` property:
* `displayName` is how the dropdown that this property represents will be named in the UI.
* `required` marks this property as required. The action will not work unless the user has selected a value.
* `refreshers` defines when the values of this property should be re-evaluated. The value `auth` in this array means that this property should only refresh when the connection that this action uses changes.
* `options()` defines the logic of how the values of this property should be populated. A quick check on the value of the `auth` property allows returning an empty set of values when a connection is not defined.
* If a connection is defined, then it's OK to make a request to the YouTrack API that gets the list of projects that exist in the connected YouTrack instance.
* When the YouTrack API request succeeds, its response is transformed into an array of objects that represent the projects. Each object has two properties: `label` and `value`. The `label` property is the text that will be shown in dropdown items, representing the name of each found YouTrack project. The `value` property contains more information about the project retrieved from the API, including its ID and short name — these will be useful later when passed to another property.
* The array is put into the `options` property of a new object that serves as the return value of the `options()` function.

If we launch OpenOps, we can see that the new action is now available in the workflow editor:

![The Change Issue Status action](/images/contributing/youtrack-change-status-action-selector.png)

If we add the action and go to the properties pane, we can see the **Project** dropdown that lists the projects available in the connected YouTrack instance:

![The Project dropdown](/images/contributing/youtrack-change-status-project-property.png)

### Adding an input property for an issue ID

The next property we'll add to `prop` is an input field that allows the user to enter the numeric part of the ID of the issue that should be updated. This type of property is simple, declarative, and doesn't contain any custom logic:

```ts
props: {
  ...
  issueId: Property.Number({
    displayName: 'Number from issue ID',
    description: 'If issue ID is PRJ-47, enter 47 in this field',
    required: true,
  }),
}
```

In the OpenOps UI, the user will be able to enter the value manually or use **Data Selector** to select a value from a previous step:

![The issue ID input field](/images/contributing/youtrack-change-status-id-property.png)

### Adding a dropdown property for the new status

The final property we'll add to `prop` is another dropdown that allows the user to select the new status for the issue. This property will show different values depending on what's selected in the **Project** dropdown.

```ts
props: {
  ...
  newStatus: Property.Dropdown({
    displayName: 'New Status',
    refreshers: ['project'],
    required: true,
    options: async ({
      auth,
      project,
    }: {
      auth?: YouTrackAuth;
      project?: YouTrackProject;
    }) => {
      if (!auth || !project) {
        return {
          disabled: true,
          options: [],
          placeholder: 'Please authenticate and specify a project',
        };
      }

      const projectCustomFieldsResponse = await httpClient.sendRequest({
        method: HttpMethod.GET,
        url: `${auth.apiUrl}/api/admin/projects/${project.id}/customFields?fields=id,field(id,name,fieldType),bundle(id)`,
        headers: {
          Authorization: `Bearer ${auth.apiKey}`,
          Accept: 'application/json',
          'Content-Type': 'application/json',
        },
      });

      const statusBundle = projectCustomFieldsResponse.body.find(
        (item: { bundle?: { $type?: string } }) =>
          item.bundle?.$type === 'StateBundle',
      );

      if (!statusBundle) {
        return {
          disabled: true,
          options: [],
          placeholder: "The selected project doesn't have a Status field.",
        };
      }

      const statusBundleId = statusBundle.bundle.id;

      const statusValuesResponse = await httpClient.sendRequest({
        method: HttpMethod.GET,
        url: `${auth.apiUrl}/api/admin/customFieldSettings/bundles/enum/${statusBundleId}/values?fields=id,name`,
        headers: {
          Authorization: `Bearer ${auth.apiKey}`,
          Accept: 'application/json',
          'Content-Type': 'application/json',
        },
      });

      return {
        disabled: false,
        options: statusValuesResponse.body.map(
          (statusValue: { name: string; id: string }) => {
            return {
              label: statusValue.name,
              value: {
                newStatusValue: statusValue,
                bundle: statusBundle,
              },
            };
          },
        ),
      };
    },
  })
}
```

It's quite a lot of code, but most of it has to do with the specifics of the YouTrack API. Let's see what exactly is going on here:
* The `refreshers` array contains `project`, meaning that this dropdown will refresh every time a new value is selected in the **Project** dropdown. This is exactly what we want because different projects will have different status values.
* The `options()` function receives two parameters: `auth` represents the block authentication and `project` holds the object representing the selected project. Remember the `value` property that we returned from `options()` of the `project` property? That's what the `project` parameter here contains.
* If either of the parameters is undefined, meaning a connection is not configured or a project is not selected, we quickly make the dropdown disabled.
* Two calls are made to YouTrack API endpoints to get the list of status values in the selected project. The first of these calls takes advantage of the `project` parameter that reflects the selected value of the **Project** dropdown. If the project doesn't have a Status field, the dropdown is disabled and a placeholder is shown.
* Once the list of status values is obtained, it's returned as an array in the `options` property representing dropdown items. The `label` is the name of each status to be shown in the dropdown, and `value` contains additional data that will be used later when the action is executed.

Looking at the OpenOps UI now, we can see that the **New Status** dropdown is available and list status value for the selected project:

![The New Status dropdown](/images/contributing/youtrack-change-status-status-property-1.png)

If we select another project that has a different set of status values, the dropdown is updated accordingly:

![The New Status dropdown for a different project](/images/contributing/youtrack-change-status-status-property-2.png)

## Summary
TODO add a link to Activepieces property reference
